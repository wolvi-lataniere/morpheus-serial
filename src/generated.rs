// This file is autogenerated, please do not edit manually
use std::convert::TryInto;
use serde_derive::Serialize;

#[derive(PartialEq, Eq, Clone, Serialize, Debug)]
pub enum Instructions {
    GetVersion{},
	SleepPin{pre_sleep_time: u16,wake_pin_active_state: bool},
	SleepTime{pre_sleep_time: u16,duration: u32}
}


#[derive(PartialEq, Eq, Clone, Serialize, Debug)]
pub enum Feedbacks {
    GetVersion{major: u8,minor: u8,patch: u8},
	SleepPin{success: bool},
	SleepTime{feedback: u8}
}




impl Feedbacks {
    pub fn to_bytes(self) -> Vec<u8> {
        match self {
            Self::GetVersion{major,minor,patch} => vec![&[0u8] as &[u8],&[major] as &[u8],&[minor] as &[u8],&[patch] as &[u8]].concat(),
			Self::SleepPin{success} => vec![&[3u8] as &[u8],&[if success {1u8} else {0u8}]].concat(),
			Self::SleepTime{feedback} => vec![&[4u8] as &[u8],&[feedback] as &[u8]].concat()
        }
    }

    pub fn from_bytes(bytes: &[u8]) -> Result<Self, ()> {
        match bytes[0] {
            0u8 => {
                let major = bytes[1];
				let minor = bytes[2];
				let patch = bytes[3];

                Ok(Self::GetVersion{major, minor, patch})
            }
                ,
			3u8 => {
                let success = bytes[1] != 0u8;

                Ok(Self::SleepPin{success})
            }
                ,
			4u8 => {
                let feedback = bytes[1];

                Ok(Self::SleepTime{feedback})
            }
                ,
    _ => Err(())
        }
    }
}

impl Instructions {
    pub fn to_bytes(self) -> Vec<u8> {
        match self {
    Self::GetVersion{} => vec![&[0u8] as &[u8],].concat(),
			Self::SleepPin{pre_sleep_time,wake_pin_active_state} => vec![&[3u8] as &[u8],&pre_sleep_time.to_le_bytes(),&[if wake_pin_active_state {1u8} else {0u8}]].concat(),
			Self::SleepTime{pre_sleep_time,duration} => vec![&[4u8] as &[u8],&pre_sleep_time.to_le_bytes(),&duration.to_le_bytes()].concat()
        }
    }

    pub fn from_bytes(bytes: &[u8]) -> Result<Self, ()> {
        match bytes[0] {
            0u8 => {
                
                Ok(Self::GetVersion{})
            }
                ,
			3u8 => {
                let pre_sleep_time = u16::from_le_bytes(bytes[1..3].try_into().unwrap());
				let wake_pin_active_state = bytes[3] != 0u8;

                Ok(Self::SleepPin{pre_sleep_time, wake_pin_active_state})
            }
                ,
			4u8 => {
                let pre_sleep_time = u16::from_le_bytes(bytes[1..3].try_into().unwrap());
				let duration = u32::from_le_bytes(bytes[3..7].try_into().unwrap());

                Ok(Self::SleepTime{pre_sleep_time, duration})
            }
                ,
    _ => Err(())
        }
    }
}
