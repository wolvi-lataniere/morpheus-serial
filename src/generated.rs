
// This file is autogenerated, please do not edit manually



#[derive(PartialEq, Eq, Clone)]
pub enum Instructions {
    SleepTime{duration: u32},
	TestParser
}


#[derive(PartialEq, Eq, Clone)]
pub enum Feedbacks {
    SleepTime{feedback: u8},
	TestParser{tesU16: u16,tesU32: u32,tesU64: u64,tesI16: i16,tesI32: i32,tesI64: i64,tesI8: i8,tesString: String}
}




impl Feedbacks {
    pub fn to_bytes(self) -> Vec<u8> {
        match self {
            Self::SleepTime{feedback} => vec![&[1u8] as &[u8],&[feedback] as &[u8]].concat(),
			Self::TestParser{tesU16,tesU32,tesU64,tesI16,tesI32,tesI64,tesI8,tesString} => vec![&[2u8] as &[u8],&tesU16.to_le_bytes(),&tesU32.to_le_bytes(),&tesU64.to_le_bytes(),&tesI16.to_le_bytes(),&tesI32.to_le_bytes(),&tesI64.to_le_bytes(),&[tesI8 as u8],tesString.as_bytes()].concat()
        }
    }

    pub fn from_bytes(bytes: &[u8]) -> Result<Self, ()> {
        match bytes[0] {
            1u8 => {
                let feedback = bytes[1];

                Ok(Self::SleepTime{feedback})
            }
                ,
			2u8 => {
                let tesU16 = u16::from_le_bytes(bytes[1..3].try_into().unwrap());
				let tesU32 = u32::from_le_bytes(bytes[3..7].try_into().unwrap());
				let tesU64 = u64::from_le_bytes(bytes[7..15].try_into().unwrap());
				let tesI16 = i16::from_le_bytes(bytes[15..17].try_into().unwrap());
				let tesI32 = i32::from_le_bytes(bytes[17..21].try_into().unwrap());
				let tesI64 = i64::from_le_bytes(bytes[21..29].try_into().unwrap());
				let tesI8 = bytes[29] as i8;
				let tesString = String::from_utf8(bytes[30..].to_vec()).unwrap();

                Ok(Self::TestParser{tesU16, tesU32, tesU64, tesI16, tesI32, tesI64, tesI8, tesString})
            }
                ,
    _ => Err(())
        }
    }
}

#[cfg(test)]
mod test{
    use crate::generated::*;

    #[test]
    fn test_encode_decode() -> Result<(), String> {
        let message = Feedbacks::TestParser{tesU16: 88u16, tesU32: 18u32, tesU64: 123883u64, tesI32: -128i32, tesI16:889i16, tesI64:-2828889i64, tesI8: 82i8, tesString: "Hello everyone".to_string()};
        let buffer = message.clone().to_bytes();
        println!("Bytes: {}", buffer.iter().map(|d| format!("{:02x}", d)).collect::<Vec<String>>().join(","));
        if let Ok(msg) = Feedbacks::from_bytes(&buffer) {
            if msg == message {
                Ok(())
            }else{Err("Messages do not match".into())}
        }
        else{Err("Failed to parse".into())}
    }
}
